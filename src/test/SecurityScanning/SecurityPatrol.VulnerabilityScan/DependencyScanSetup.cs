using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using Xunit.Abstractions;
using OWASP.DependencyCheck.Core;
using OWASP.DependencyCheck.Reporting;
using OWASP.DependencyCheck.Analyzers;
using Microsoft.Extensions.Logging;

namespace SecurityPatrol.VulnerabilityScan
{
    /// <summary>
    /// Provides setup and configuration for dependency vulnerability scanning in the Security Patrol application.
    /// This class initializes and configures the OWASP Dependency Check scanning engine and manages
    /// resources needed for scanning dependencies for security vulnerabilities.
    /// </summary>
    public class DependencyScanSetup
    {
        /// <summary>
        /// Gets the test output helper for logging information during scans.
        /// </summary>
        public ITestOutputHelper Output { get; private set; }

        /// <summary>
        /// Gets the path to the solution directory.
        /// </summary>
        public string SolutionDirectory { get; private set; }

        /// <summary>
        /// Gets the path to the report output directory.
        /// </summary>
        public string ReportOutputDirectory { get; private set; }

        /// <summary>
        /// Gets the path to the vulnerability suppression file.
        /// </summary>
        public string SuppressionFilePath { get; private set; }

        /// <summary>
        /// Gets a value indicating whether the scan setup has been initialized.
        /// </summary>
        public bool IsInitialized { get; private set; }

        /// <summary>
        /// Gets the OWASP Dependency Check scan engine.
        /// </summary>
        public object ScanEngine { get; private set; }

        /// <summary>
        /// Gets the dictionary of project groups categorized by type.
        /// </summary>
        public Dictionary<string, List<string>> ProjectGroups { get; private set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="DependencyScanSetup"/> class.
        /// </summary>
        /// <param name="output">The test output helper for logging.</param>
        public DependencyScanSetup(ITestOutputHelper output)
        {
            Output = output ?? throw new ArgumentNullException(nameof(output));
            IsInitialized = false;
            ProjectGroups = new Dictionary<string, List<string>>();
            ScanEngine = null;
        }

        /// <summary>
        /// Initializes the dependency scanning environment asynchronously.
        /// Sets up the solution directory, report directory, suppression file,
        /// discovers projects, and configures the scan engine.
        /// </summary>
        /// <returns>A task representing the asynchronous initialization operation.</returns>
        public async Task Initialize()
        {
            // Determine solution directory path
            SolutionDirectory = DetermineSolutionDirectory();
            Output.WriteLine($"Solution directory identified: {SolutionDirectory}");

            // Create report output directory
            ReportOutputDirectory = Path.Combine(SolutionDirectory, "SecurityReports", "DependencyCheck");
            if (!Directory.Exists(ReportOutputDirectory))
            {
                Directory.CreateDirectory(ReportOutputDirectory);
                Output.WriteLine($"Created report output directory: {ReportOutputDirectory}");
            }

            // Setup suppression file
            SuppressionFilePath = CreateDefaultSuppressionFile();
            Output.WriteLine($"Using suppression file: {SuppressionFilePath}");

            // Discover projects
            ProjectGroups = DiscoverProjects();
            Output.WriteLine($"Discovered {ProjectGroups.Values.SelectMany(x => x).Count()} projects across {ProjectGroups.Count} groups");

            // Configure scan engine
            ScanEngine = ConfigureScanEngine();
            Output.WriteLine("Scan engine configured successfully");

            // Initialize NVD data feed if needed
            await InitializeNvdDataFeed();

            IsInitialized = true;
            Output.WriteLine("Dependency scan setup initialized successfully");
        }

        /// <summary>
        /// Gets the configured OWASP Dependency Check scan engine.
        /// </summary>
        /// <returns>The configured scan engine instance.</returns>
        /// <exception cref="InvalidOperationException">Thrown if the setup has not been initialized.</exception>
        public object GetScanEngine()
        {
            if (!IsInitialized)
            {
                throw new InvalidOperationException("Scan setup must be initialized before accessing the scan engine.");
            }

            return ScanEngine;
        }

        /// <summary>
        /// Gets the path to the vulnerability suppression file.
        /// </summary>
        /// <returns>The path to the suppression file.</returns>
        /// <exception cref="InvalidOperationException">Thrown if the setup has not been initialized.</exception>
        public string GetSuppressionFile()
        {
            if (!IsInitialized)
            {
                throw new InvalidOperationException("Scan setup must be initialized before accessing the suppression file.");
            }

            return SuppressionFilePath;
        }

        /// <summary>
        /// Gets the project file paths for the specified project group.
        /// </summary>
        /// <param name="groupName">The name of the project group.</param>
        /// <returns>A list of project file paths for the specified group.</returns>
        /// <exception cref="InvalidOperationException">Thrown if the setup has not been initialized.</exception>
        /// <exception cref="ArgumentException">Thrown if the specified group does not exist.</exception>
        public List<string> GetProjectPaths(string groupName)
        {
            if (!IsInitialized)
            {
                throw new InvalidOperationException("Scan setup must be initialized before accessing project paths.");
            }

            if (!ProjectGroups.ContainsKey(groupName))
            {
                throw new ArgumentException($"Project group '{groupName}' does not exist.", nameof(groupName));
            }

            return ProjectGroups[groupName];
        }

        /// <summary>
        /// Gets all discovered project file paths across all groups.
        /// </summary>
        /// <returns>A list of all project file paths.</returns>
        /// <exception cref="InvalidOperationException">Thrown if the setup has not been initialized.</exception>
        public List<string> GetAllProjectPaths()
        {
            if (!IsInitialized)
            {
                throw new InvalidOperationException("Scan setup must be initialized before accessing project paths.");
            }

            return ProjectGroups.Values.SelectMany(projects => projects).ToList();
        }

        /// <summary>
        /// Discovers and categorizes projects for scanning.
        /// </summary>
        /// <returns>A dictionary of project groups categorized by type.</returns>
        private Dictionary<string, List<string>> DiscoverProjects()
        {
            var result = new Dictionary<string, List<string>>
            {
                { "Mobile", new List<string>() },
                { "Backend", new List<string>() },
                { "Common", new List<string>() },
                { "Test", new List<string>() }
            };

            var projectFiles = Directory.GetFiles(SolutionDirectory, "*.csproj", SearchOption.AllDirectories);
            
            foreach (var projectFile in projectFiles)
            {
                var projectContent = File.ReadAllText(projectFile);
                var projectFileName = Path.GetFileNameWithoutExtension(projectFile);
                
                // Categorize projects based on name or content
                if (projectFileName.Contains("Test") || projectFileName.Contains("Tests") || 
                    projectContent.Contains("<IsTestProject>true</IsTestProject>"))
                {
                    result["Test"].Add(projectFile);
                }
                else if (projectContent.Contains("<UseMaui>true</UseMaui>") || 
                         projectFileName.Contains("Android") || projectFileName.Contains("iOS") ||
                         projectFileName.Contains("Mobile") || projectFileName.Contains("App"))
                {
                    result["Mobile"].Add(projectFile);
                }
                else if (projectFileName.Contains("API") || projectFileName.Contains("Service") || 
                         projectFileName.Contains("Backend") || projectFileName.Contains("Server"))
                {
                    result["Backend"].Add(projectFile);
                }
                else
                {
                    result["Common"].Add(projectFile);
                }
            }

            // Log discovered project counts
            foreach (var group in result)
            {
                Output.WriteLine($"Discovered {group.Value.Count} {group.Key} projects");
            }

            return result;
        }

        /// <summary>
        /// Determines the solution directory path by searching upward from the current directory.
        /// </summary>
        /// <returns>The path to the solution directory.</returns>
        /// <exception cref="DirectoryNotFoundException">Thrown if the solution directory cannot be found.</exception>
        private string DetermineSolutionDirectory()
        {
            var directory = new DirectoryInfo(AppContext.BaseDirectory);
            
            // Navigate up until we find a directory with a .sln file or reach the root
            while (directory != null && !directory.GetFiles("*.sln").Any())
            {
                directory = directory.Parent;
            }

            if (directory == null)
            {
                throw new DirectoryNotFoundException("Could not find the solution directory. Make sure the tests are run from within the solution.");
            }

            return directory.FullName;
        }

        /// <summary>
        /// Configures the OWASP Dependency Check scan engine with appropriate settings.
        /// </summary>
        /// <returns>The configured scan engine instance.</returns>
        private object ConfigureScanEngine()
        {
            try
            {
                // Create new scan engine instance
                var engine = new Engine(AppContext.BaseDirectory);
                
                // Configure engine settings
                engine.Config.SuppressUpdateCheck = true;
                engine.Config.AutoUpdate = true;
                engine.Config.SuppressionFile = SuppressionFilePath;
                
                // Configure output formats
                engine.Config.OutputFormats = new List<string> { "HTML", "XML", "JSON" };
                engine.Config.OutputDirectory = ReportOutputDirectory;
                
                // Configure scan options
                engine.Config.FailOnCVSS = 7.0f;  // CVSS threshold for high severity
                engine.Config.ShowEvidence = true;
                engine.Config.ScanTimeout = 300000;  // 5 minutes timeout
                
                // Set up analyzers for different dependency types
                engine.Config.Analyzers["nugetconf"].Enabled = true;
                engine.Config.Analyzers["nuspec"].Enabled = true;
                engine.Config.Analyzers["assembly"].Enabled = true;
                engine.Config.Analyzers["msbuild"].Enabled = true;
                
                // Disable analyzers that aren't relevant for .NET projects
                engine.Config.Analyzers["node-package-json"].Enabled = false;
                engine.Config.Analyzers["node-audit-json"].Enabled = false;
                engine.Config.Analyzers["pip"].Enabled = false;
                
                return engine;
            }
            catch (Exception ex)
            {
                Output.WriteLine($"Error configuring scan engine: {ex.Message}");
                throw;
            }
        }

        /// <summary>
        /// Initializes the National Vulnerability Database (NVD) data feed.
        /// </summary>
        /// <returns>A task representing the asynchronous initialization operation.</returns>
        private async Task InitializeNvdDataFeed()
        {
            try
            {
                // Cast to Engine to access specific methods
                var engine = ScanEngine as Engine;
                if (engine == null) 
                {
                    throw new InvalidOperationException("Scan engine is not properly initialized.");
                }
                
                // Check if NVD data is current
                var needsUpdate = engine.DoesNvdNeedUpdate();
                
                if (needsUpdate)
                {
                    Output.WriteLine("NVD data update is required. Downloading latest vulnerability data...");
                    
                    // Use Task.Run to perform the update asynchronously
                    await Task.Run(() => engine.UpdateNvd(false));
                    
                    Output.WriteLine("NVD data updated successfully.");
                }
                else
                {
                    Output.WriteLine("NVD data is already up to date.");
                }
            }
            catch (Exception ex)
            {
                Output.WriteLine($"Error initializing NVD data feed: {ex.Message}");
                // Continue rather than throw as this is not critical - can use cached data
            }
        }

        /// <summary>
        /// Creates a default suppression file if none exists.
        /// </summary>
        /// <returns>The path to the suppression file.</returns>
        private string CreateDefaultSuppressionFile()
        {
            var suppressionFilePath = Path.Combine(SolutionDirectory, "SecurityReports", "dependency-suppressions.xml");
            
            // Create directory if it doesn't exist
            var directory = Path.GetDirectoryName(suppressionFilePath);
            if (directory != null && !Directory.Exists(directory))
            {
                Directory.CreateDirectory(directory);
            }

            // Create default suppression file if it doesn't exist
            if (!File.Exists(suppressionFilePath))
            {
                var defaultContent = @"<?xml version=""1.0"" encoding=""UTF-8""?>
<suppressions xmlns=""https://jeremylong.github.io/DependencyCheck/dependency-suppression.1.3.xsd"">
    <!-- 
    Add suppression rules here in the format:
    <suppress>
        <notes>Reason for suppression</notes>
        <packageUrl regex="true">pkg:nuget/PACKAGE@VERSION</packageUrl>
        <cve>CVE-XXXX-YYYY</cve>
    </suppress>
    -->
</suppressions>";
                
                File.WriteAllText(suppressionFilePath, defaultContent);
                Output.WriteLine($"Created default suppression file at: {suppressionFilePath}");
            }

            return suppressionFilePath;
        }

        /// <summary>
        /// Cleans up resources after dependency scanning.
        /// </summary>
        public void Cleanup()
        {
            if (ScanEngine is IDisposable disposable)
            {
                disposable.Dispose();
                Output.WriteLine("Scan engine disposed.");
            }

            // Clean up any temporary files if needed
            var tempDir = Path.Combine(AppContext.BaseDirectory, "dependency-check-data");
            if (Directory.Exists(tempDir))
            {
                try
                {
                    Directory.Delete(tempDir, true);
                    Output.WriteLine("Temporary dependency check data cleaned up.");
                }
                catch (Exception ex)
                {
                    Output.WriteLine($"Warning: Failed to clean up temporary files: {ex.Message}");
                    // Non-critical, so just log the error
                }
            }

            Output.WriteLine("Dependency scan cleanup completed.");
        }
    }
}