using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using Xunit;
using Xunit.Abstractions;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.Build;

namespace SecurityPatrol.VulnerabilityScan
{
    /// <summary>
    /// Implements tests for static code analysis to identify security vulnerabilities in the Security Patrol application codebase.
    /// </summary>
    public class StaticCodeAnalysisTests
    {
        public ITestOutputHelper Output { get; private set; }
        public DependencyScanSetup ScanSetup { get; private set; }
        public string ReportOutputPath { get; private set; }
        public string RulesetPath { get; private set; }
        public Dictionary<string, int> MaxAllowedViolationsByRule { get; private set; }
        public Dictionary<string, List<string>> ExcludedFiles { get; private set; }

        /// <summary>
        /// Initializes a new instance of the StaticCodeAnalysisTests class with test output helper.
        /// </summary>
        /// <param name="output">The test output helper for logging.</param>
        public StaticCodeAnalysisTests(ITestOutputHelper output)
        {
            Output = output ?? throw new ArgumentNullException(nameof(output));
            ScanSetup = new DependencyScanSetup(output);
            ReportOutputPath = null; // Will be set during initialization
            RulesetPath = Path.Combine(AppContext.BaseDirectory, "CodeAnalysisRules.ruleset");
            
            // Initialize rule thresholds
            MaxAllowedViolationsByRule = new Dictionary<string, int>
            {
                // Security rules - zero tolerance for security vulnerabilities
                { "CA2100", 0 },  // Review SQL queries for security vulnerabilities
                { "CA3001", 0 },  // Review code for SQL injection vulnerabilities
                { "CA3002", 0 },  // Review code for XSS vulnerabilities
                { "CA3003", 0 },  // Review code for file path injection vulnerabilities
                { "CA3004", 0 },  // Review code for information disclosure vulnerabilities
                { "CA3005", 0 },  // Review code for LDAP injection vulnerabilities
                { "CA3006", 0 },  // Review code for process command injection vulnerabilities
                { "CA3007", 0 },  // Review code for open redirect vulnerabilities
                { "CA3008", 0 },  // Review code for XPath injection vulnerabilities
                { "CA3009", 0 },  // Review code for XML injection vulnerabilities
                { "CA3010", 0 },  // Review code for XAML injection vulnerabilities
                { "CA3011", 0 },  // Review code for DLL injection vulnerabilities
                { "CA3012", 0 },  // Review code for regex injection vulnerabilities
                { "CA5350", 0 },  // Do Not Use Weak Cryptographic Algorithms
                { "CA5351", 0 },  // Do Not Use Broken Cryptographic Algorithms
                { "CA5358", 0 },  // Do Not Use Unsafe Cipher Modes
                { "CA5359", 0 },  // Do Not Disable Certificate Validation
                { "CA5360", 0 },  // Do Not Use Insecure Deserializer
                { "CA5361", 0 },  // Do Not Disable SChannel Use of Strong Crypto
                { "CA5362", 0 },  // Potential reference cycle in deserialized object graph
                { "CA5363", 0 },  // Do Not Disable Request Validation
                { "CA5364", 0 },  // Do Not Use Deprecated Security Protocols
                { "CA5365", 0 },  // Do Not Disable HTTP Header Checking
                { "CA5366", 0 },  // Use XmlReader for DataSet Read XML
                { "CA5367", 0 },  // Do Not Serialize Types With Pointer Fields
                { "CA5368", 0 },  // Set ViewStateUserKey For Classes Derived From Page
                { "CA5369", 0 },  // Use XmlReader for Deserialize
                { "CA5370", 0 },  // Use XmlReader for ValidatingReader
                { "CA5371", 0 },  // Use XmlReader for Schema Read
                { "CA5372", 0 },  // Use XmlReader for XPathDocument
                { "CA5373", 0 },  // Do not use obsolete key derivation function
                { "CA5374", 0 },  // Do Not Use XslTransform
                { "CA5375", 0 },  // Do Not Use Account Shared Access Signature
                { "CA5376", 0 },  // Use SharedAccessProtocol HttpsOnly
                { "CA5377", 0 },  // Use Container Level Access Policy
                { "CA5378", 0 },  // Do not disable ServicePointManagerSecurityProtocols
                { "CA5379", 0 },  // Ensure Key Derivation Function algorithm is sufficiently strong
                { "CA5380", 0 },  // Do Not Add Certificates To Root Store
                { "CA5381", 0 },  // Ensure Certificates Are Not Added To Root Store
                { "CA5382", 0 },  // Use Secure Cookies In ASP.Net Core
                { "CA5383", 0 },  // Ensure Use Secure Cookies In ASP.Net Core
                { "CA5384", 0 },  // Do Not Use Digital Signature Algorithm (DSA)
                { "CA5385", 0 },  // Use Rivest–Shamir–Adleman (RSA) Algorithm With Sufficient Key Size
                { "CA5386", 0 },  // Avoid hardcoding SecurityProtocolType
                { "CA5387", 0 },  // Do Not Use Weak Key Derivation Function With Insufficient Iteration Count
                { "CA5388", 0 },  // Ensure Sufficient Iteration Count When Using Weak Key Derivation Function
                { "CA5389", 0 },  // Do Not Add Archive Item's Path To The Target File System Path
                { "CA5390", 0 },  // Do not hard-code encryption key
                { "CA5391", 0 },  // Use antiforgery tokens in ASP.NET Core MVC controllers
                { "CA5392", 0 },  // Use DefaultDllImportSearchPaths attribute for P/Invokes
                { "CA5393", 0 },  // Do not use unsafe DllImportSearchPath value
                { "CA5394", 0 },  // Do not use insecure randomness
                { "CA5395", 0 },  // Miss HttpVerb attribute for action methods
                { "CA5396", 0 },  // Set HttpOnly to true for HttpCookie
                { "CA5397", 0 },  // Do not use deprecated SslProtocols values
                { "CA5398", 0 },  // Avoid hardcoded SslProtocols values
                { "CA5399", 0 },  // HttpClients should enable certificate revocation list checks
                
                // OWASP Security Code Scan rules
                { "SCS0001", 0 }, // Command Injection
                { "SCS0002", 0 }, // SQL Injection
                { "SCS0003", 0 }, // XPath Injection
                { "SCS0004", 0 }, // LDAP Injection
                { "SCS0005", 0 }, // XAML Injection
                { "SCS0006", 0 }, // XML Injection
                { "SCS0007", 0 }, // XML External Entity Injection (XXE)
                { "SCS0008", 0 }, // Cookie Without SSL Flag
                { "SCS0009", 0 }, // Cookie Without HttpOnly Flag
                { "SCS0010", 0 }, // Weak Cryptography Algorithm
                { "SCS0011", 0 }, // Weak Password Hashing
                { "SCS0012", 0 }, // Weak Crypto Random Generator
                { "SCS0013", 0 }, // Potential WebView JavaScript injection
                { "SCS0014", 0 }, // SQL Injection in ORM
                { "SCS0015", 0 }, // Hardcoded Password
                { "SCS0016", 0 }, // Cross-Site Request Forgery
                { "SCS0017", 0 }, // Request Validation Disabled
                { "SCS0018", 0 }, // Path Traversal
                { "SCS0019", 0 }, // OutputCache Conflict
                { "SCS0020", 0 }, // Open Redirect
                { "SCS0021", 0 }, // Request Headers Injection
                { "SCS0022", 0 }, // Form Validation Missing
                { "SCS0023", 0 }, // View State Not Encrypted
                { "SCS0024", 0 }, // View State MAC Disabled
                { "SCS0025", 0 }, // Event Validation Disabled
                { "SCS0026", 0 }, // Insecure HTTP Packet Header Checker
                { "SCS0027", 0 }, // Open Redirect in PageAndMaster
                { "SCS0028", 0 }, // Insecure Deserialization
                { "SCS0029", 0 }, // Cross-Site Scripting (XSS)
                { "SCS0030", 0 }, // Request Validation Bypass
                { "SCS0031", 0 }, // LDAP Distinguished Name Injection
                { "SCS0032", 0 }, // SQLite SQL Injection
                { "SCS0033", 0 }, // Password Management Hardcoded Value
                { "SCS0034", 0 }, // MongoDB Query Injection
                { "SCS0035", 0 }, // Multiple binds to the same port
                { "SCS0036", 0 }, // TypeNameHandling is insecure
                
                // Allow some less critical rules to have a few violations
                { "CA1822", 5 },  // Mark members as static
                { "CA1801", 5 }   // Review unused parameters
            };
            
            // Initialize files to exclude from specific rule checks
            ExcludedFiles = new Dictionary<string, List<string>>
            {
                // Exclude test files from hardcoded password checks
                { "SCS0015", new List<string> { "*Test*.cs", "*Mock*.cs" } },
                // Exclude generated files from various checks
                { "CA1822", new List<string> { "*.g.cs", "*.Designer.cs" } },
                // Exclude test data from SQL injection checks
                { "CA2100", new List<string> { "*TestData*.cs" } },
                // Exclude mock services from security protocol checks
                { "CA5364", new List<string> { "*Mock*.cs", "*Fake*.cs" } },
                // Exclude test utilities from certificate validation checks
                { "CA5359", new List<string> { "*TestUtil*.cs" } }
            };
        }

        /// <summary>
        /// Initializes the static code analysis environment asynchronously.
        /// </summary>
        /// <returns>A task representing the asynchronous initialization operation.</returns>
        [Fact(Skip = "Run manually due to long execution time")]
        public async Task InitializeAsync()
        {
            // Create output directory if it doesn't exist
            var reportDir = Path.Combine(AppContext.BaseDirectory, "SecurityReports", "StaticAnalysis");
            if (!Directory.Exists(reportDir))
            {
                Directory.CreateDirectory(reportDir);
            }
            
            ReportOutputPath = reportDir;
            
            // Verify ruleset file exists
            if (!File.Exists(RulesetPath))
            {
                Output.WriteLine($"Warning: Ruleset file not found at {RulesetPath}. Will use default analyzer rules.");
            }
            else
            {
                Output.WriteLine($"Using ruleset file: {RulesetPath}");
            }
            
            Output.WriteLine("Static code analysis environment initialized successfully");
        }

        /// <summary>
        /// Analyzes all projects for security vulnerabilities using static code analysis.
        /// </summary>
        /// <returns>A task representing the asynchronous analysis operation.</returns>
        [Fact(Skip = "Run manually due to long execution time")]
        public async Task AnalyzeAllProjects()
        {
            // Initialize if not already done
            if (ReportOutputPath == null)
            {
                await InitializeAsync();
            }
            
            // Get all project paths
            var projectPaths = ScanSetup.GetAllProjectPaths();
            
            // Load ruleset
            var ruleset = LoadRuleset();
            
            // Run code analysis
            var results = await RunCodeAnalysis(projectPaths, "AllProjects", false);
            
            // Process results
            var violationCounts = ProcessAnalysisResults(results);
            
            // Generate report
            var reportPath = await GenerateSecurityReport(results, "AllProjects");
            
            // Assert results
            foreach (var violation in violationCounts)
            {
                var ruleId = violation.Key;
                var count = violation.Value;
                var allowedCount = MaxAllowedViolationsByRule.ContainsKey(ruleId) 
                    ? MaxAllowedViolationsByRule[ruleId] 
                    : 0;
                    
                Assert.True(count <= allowedCount, 
                    $"Rule {ruleId} has {count} violations, which exceeds the maximum allowed {allowedCount}. " +
                    $"See report for details: {reportPath}");
            }
            
            Output.WriteLine($"Static code analysis completed successfully. Report generated at: {reportPath}");
        }

        /// <summary>
        /// Analyzes mobile application code for security vulnerabilities.
        /// </summary>
        /// <returns>A task representing the asynchronous analysis operation.</returns>
        [Fact(Skip = "Run manually due to long execution time")]
        public async Task AnalyzeMobileApp()
        {
            // Initialize if not already done
            if (ReportOutputPath == null)
            {
                await InitializeAsync();
            }
            
            // Get mobile project paths
            var projectPaths = ScanSetup.GetProjectPaths("Mobile");
            
            // Load ruleset
            var ruleset = LoadRuleset();
            
            // Run code analysis
            var results = await RunCodeAnalysis(projectPaths, "MobileApp", false);
            
            // Process results
            var violationCounts = ProcessAnalysisResults(results);
            
            // Generate report
            var reportPath = await GenerateSecurityReport(results, "MobileApp");
            
            // Assert results
            foreach (var violation in violationCounts)
            {
                var ruleId = violation.Key;
                var count = violation.Value;
                var allowedCount = MaxAllowedViolationsByRule.ContainsKey(ruleId) 
                    ? MaxAllowedViolationsByRule[ruleId] 
                    : 0;
                    
                Assert.True(count <= allowedCount, 
                    $"Rule {ruleId} has {count} violations, which exceeds the maximum allowed {allowedCount}. " +
                    $"See report for details: {reportPath}");
            }
            
            Output.WriteLine($"Mobile app static code analysis completed successfully. Report generated at: {reportPath}");
        }

        /// <summary>
        /// Analyzes backend application code for security vulnerabilities.
        /// </summary>
        /// <returns>A task representing the asynchronous analysis operation.</returns>
        [Fact(Skip = "Run manually due to long execution time")]
        public async Task AnalyzeBackendCode()
        {
            // Initialize if not already done
            if (ReportOutputPath == null)
            {
                await InitializeAsync();
            }
            
            // Get backend project paths
            var projectPaths = ScanSetup.GetProjectPaths("Backend");
            
            // Load ruleset
            var ruleset = LoadRuleset();
            
            // Run code analysis
            var results = await RunCodeAnalysis(projectPaths, "BackendCode", false);
            
            // Process results
            var violationCounts = ProcessAnalysisResults(results);
            
            // Generate report
            var reportPath = await GenerateSecurityReport(results, "BackendCode");
            
            // Assert results
            foreach (var violation in violationCounts)
            {
                var ruleId = violation.Key;
                var count = violation.Value;
                var allowedCount = MaxAllowedViolationsByRule.ContainsKey(ruleId) 
                    ? MaxAllowedViolationsByRule[ruleId] 
                    : 0;
                    
                Assert.True(count <= allowedCount, 
                    $"Rule {ruleId} has {count} violations, which exceeds the maximum allowed {allowedCount}. " +
                    $"See report for details: {reportPath}");
            }
            
            Output.WriteLine($"Backend code static code analysis completed successfully. Report generated at: {reportPath}");
        }

        /// <summary>
        /// Verifies compliance with critical security rules across all projects.
        /// </summary>
        /// <returns>A task representing the asynchronous verification operation.</returns>
        [Fact(Skip = "Run manually due to long execution time")]
        public async Task VerifySecurityRuleCompliance()
        {
            // Initialize if not already done
            if (ReportOutputPath == null)
            {
                await InitializeAsync();
            }
            
            // Get all project paths
            var projectPaths = ScanSetup.GetAllProjectPaths();
            
            // Load ruleset
            var ruleset = LoadRuleset();
            
            // Get critical security rules
            var criticalRules = GetCriticalSecurityRules(ruleset);
            
            // Run code analysis with only critical security rules
            var results = await RunCodeAnalysis(projectPaths, "SecurityCompliance", true);
            
            // Process results
            var violationCounts = ProcessAnalysisResults(results);
            
            // Generate report
            var reportPath = await GenerateSecurityReport(results, "SecurityCompliance");
            
            // Assert results - for critical security rules, we want zero violations
            foreach (var violation in violationCounts)
            {
                var ruleId = violation.Key;
                if (IsSecurityRule(ruleId))
                {
                    Assert.Equal(0, violation.Value, 
                        $"Security rule {ruleId} has {violation.Value} violations, but zero are allowed. " +
                        $"See report for details: {reportPath}");
                }
            }
            
            Output.WriteLine($"Security rule compliance verification completed successfully. Report generated at: {reportPath}");
        }

        /// <summary>
        /// Runs static code analysis on specified projects with configured ruleset.
        /// </summary>
        /// <param name="projectPaths">List of project file paths to analyze.</param>
        /// <param name="outputName">Name for the output report.</param>
        /// <param name="criticalRulesOnly">Whether to analyze only for critical security rules.</param>
        /// <returns>Dictionary of rule violations by rule ID.</returns>
        private async Task<Dictionary<string, List<DiagnosticResult>>> RunCodeAnalysis(
            List<string> projectPaths, 
            string outputName,
            bool criticalRulesOnly)
        {
            var workspace = new AdhocWorkspace();
            var ruleViolations = new Dictionary<string, List<DiagnosticResult>>();
            
            Output.WriteLine($"Starting static code analysis on {projectPaths.Count} projects...");
            
            // Load ruleset
            var ruleset = LoadRuleset();
            
            // Filter for critical security rules if requested
            var enabledRules = criticalRulesOnly
                ? GetCriticalSecurityRules(ruleset)
                : ruleset.Keys.ToList();
                
            Output.WriteLine($"Analyzing with {enabledRules.Count} rules" + 
                (criticalRulesOnly ? " (critical security rules only)" : ""));
            
            foreach (var projectPath in projectPaths)
            {
                try
                {
                    Output.WriteLine($"Analyzing project: {Path.GetFileName(projectPath)}");
                    
                    // Create and configure project
                    var project = await CreateProjectFromPath(workspace, projectPath);
                    if (project == null)
                    {
                        Output.WriteLine($"Skipping project {Path.GetFileName(projectPath)} - could not load");
                        continue;
                    }
                    
                    // Get compilation
                    var compilation = await project.GetCompilationAsync();
                    if (compilation == null)
                    {
                        Output.WriteLine($"Skipping project {Path.GetFileName(projectPath)} - could not compile");
                        continue;
                    }
                    
                    // Configure analyzers
                    var analyzers = ConfigureAnalyzers(enabledRules);
                    
                    // Analyze
                    var compilationWithAnalyzers = compilation.WithAnalyzers(analyzers);
                    var diagnostics = await compilationWithAnalyzers.GetAnalyzerDiagnosticsAsync();
                    
                    // Process diagnostics
                    foreach (var diagnostic in diagnostics)
                    {
                        // Skip diagnostics from excluded files
                        if (ShouldExcludeFile(diagnostic.Location.GetLineSpan().Path, diagnostic.Id))
                        {
                            continue;
                        }
                        
                        // Skip non-security rules if criticalRulesOnly is true
                        if (criticalRulesOnly && !IsSecurityRule(diagnostic.Id))
                        {
                            continue;
                        }
                        
                        var result = new DiagnosticResult
                        {
                            Id = diagnostic.Id,
                            Severity = diagnostic.Severity.ToString(),
                            Location = diagnostic.Location.GetLineSpan().ToString(),
                            Message = diagnostic.GetMessage(),
                            ProjectName = Path.GetFileNameWithoutExtension(projectPath),
                            FilePath = diagnostic.Location.GetLineSpan().Path
                        };
                        
                        if (!ruleViolations.ContainsKey(diagnostic.Id))
                        {
                            ruleViolations[diagnostic.Id] = new List<DiagnosticResult>();
                        }
                        
                        ruleViolations[diagnostic.Id].Add(result);
                    }
                }
                catch (Exception ex)
                {
                    Output.WriteLine($"Error analyzing project {Path.GetFileName(projectPath)}: {ex.Message}");
                }
            }
            
            return ruleViolations;
        }

        /// <summary>
        /// Processes the results of static code analysis.
        /// </summary>
        /// <param name="results">Dictionary of rule violations by rule ID.</param>
        /// <returns>Dictionary of violation counts by rule ID.</returns>
        private Dictionary<string, int> ProcessAnalysisResults(Dictionary<string, List<DiagnosticResult>> results)
        {
            var violationCounts = new Dictionary<string, int>();
            var totalViolations = 0;
            
            foreach (var rule in results)
            {
                violationCounts[rule.Key] = rule.Value.Count;
                totalViolations += rule.Value.Count;
                
                Output.WriteLine($"Rule {rule.Key}: {rule.Value.Count} violations");
            }
            
            Output.WriteLine($"Total violations found: {totalViolations}");
            
            return violationCounts;
        }

        /// <summary>
        /// Generates a detailed report of identified security vulnerabilities.
        /// </summary>
        /// <param name="results">Dictionary of rule violations by rule ID.</param>
        /// <param name="reportName">Name for the report.</param>
        /// <returns>Path to the generated report file.</returns>
        private async Task<string> GenerateSecurityReport(
            Dictionary<string, List<DiagnosticResult>> results,
            string reportName)
        {
            var reportFilePath = Path.Combine(ReportOutputPath, $"{reportName}_Report.html");
            var csvFilePath = Path.Combine(ReportOutputPath, $"{reportName}_Report.csv");
            
            // Extract all violations and details
            var violations = new List<DiagnosticResult>();
            foreach (var rule in results)
            {
                violations.AddRange(rule.Value);
            }
            
            // Group violations by file
            var violationsByFile = violations
                .GroupBy(v => v.FilePath)
                .OrderBy(g => g.Key)
                .ToList();
                
            // Create HTML report
            using (var writer = new StreamWriter(reportFilePath))
            {
                await writer.WriteLineAsync("<!DOCTYPE html>");
                await writer.WriteLineAsync("<html>");
                await writer.WriteLineAsync("<head>");
                await writer.WriteLineAsync("<title>Security Static Analysis Report</title>");
                await writer.WriteLineAsync("<style>");
                await writer.WriteLineAsync("body { font-family: Arial, sans-serif; margin: 20px; }");
                await writer.WriteLineAsync("h1 { color: #2c3e50; }");
                await writer.WriteLineAsync("h2 { color: #3498db; }");
                await writer.WriteLineAsync("h3 { color: #2c3e50; }");
                await writer.WriteLineAsync("table { border-collapse: collapse; width: 100%; margin-bottom: 20px; }");
                await writer.WriteLineAsync("th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }");
                await writer.WriteLineAsync("th { background-color: #f2f2f2; }");
                await writer.WriteLineAsync("tr:nth-child(even) { background-color: #f9f9f9; }");
                await writer.WriteLineAsync(".severity-Error { color: #e74c3c; font-weight: bold; }");
                await writer.WriteLineAsync(".severity-Warning { color: #e67e22; }");
                await writer.WriteLineAsync(".severity-Info { color: #3498db; }");
                await writer.WriteLineAsync(".summary { margin-bottom: 30px; }");
                await writer.WriteLineAsync(".file-section { margin-bottom: 30px; }");
                await writer.WriteLineAsync("</style>");
                await writer.WriteLineAsync("</head>");
                await writer.WriteLineAsync("<body>");
                
                // Header
                await writer.WriteLineAsync($"<h1>Security Static Analysis Report - {reportName}</h1>");
                await writer.WriteLineAsync($"<p>Generated on {DateTime.Now}</p>");
                
                // Summary
                await writer.WriteLineAsync("<div class='summary'>");
                await writer.WriteLineAsync("<h2>Summary</h2>");
                await writer.WriteLineAsync("<table>");
                await writer.WriteLineAsync("<tr><th>Rule ID</th><th>Description</th><th>Severity</th><th>Count</th></tr>");
                
                var ruleGroups = violations
                    .GroupBy(v => v.Id)
                    .OrderBy(g => g.Key)
                    .ToList();
                    
                foreach (var ruleGroup in ruleGroups)
                {
                    var ruleId = ruleGroup.Key;
                    var count = ruleGroup.Count();
                    var severity = ruleGroup.First().Severity;
                    var description = ruleGroup.First().Message.Split('.')[0] + "."; // First sentence
                    
                    await writer.WriteLineAsync($"<tr>");
                    await writer.WriteLineAsync($"<td>{ruleId}</td>");
                    await writer.WriteLineAsync($"<td>{description}</td>");
                    await writer.WriteLineAsync($"<td class='severity-{severity}'>{severity}</td>");
                    await writer.WriteLineAsync($"<td>{count}</td>");
                    await writer.WriteLineAsync($"</tr>");
                }
                
                await writer.WriteLineAsync("</table>");
                await writer.WriteLineAsync($"<p><strong>Total Violations:</strong> {violations.Count}</p>");
                await writer.WriteLineAsync("</div>");
                
                // Detailed violations by file
                await writer.WriteLineAsync("<h2>Detailed Findings</h2>");
                
                foreach (var fileGroup in violationsByFile)
                {
                    var filePath = fileGroup.Key;
                    var fileName = Path.GetFileName(filePath);
                    
                    await writer.WriteLineAsync("<div class='file-section'>");
                    await writer.WriteLineAsync($"<h3>File: {fileName}</h3>");
                    await writer.WriteLineAsync($"<p>Path: {filePath}</p>");
                    await writer.WriteLineAsync("<table>");
                    await writer.WriteLineAsync("<tr><th>Rule ID</th><th>Severity</th><th>Location</th><th>Message</th></tr>");
                    
                    foreach (var violation in fileGroup.OrderBy(v => v.Id))
                    {
                        await writer.WriteLineAsync($"<tr>");
                        await writer.WriteLineAsync($"<td>{violation.Id}</td>");
                        await writer.WriteLineAsync($"<td class='severity-{violation.Severity}'>{violation.Severity}</td>");
                        await writer.WriteLineAsync($"<td>{violation.Location}</td>");
                        await writer.WriteLineAsync($"<td>{violation.Message}</td>");
                        await writer.WriteLineAsync($"</tr>");
                    }
                    
                    await writer.WriteLineAsync("</table>");
                    await writer.WriteLineAsync("</div>");
                }
                
                await writer.WriteLineAsync("</body>");
                await writer.WriteLineAsync("</html>");
            }
            
            // Create CSV report
            using (var writer = new StreamWriter(csvFilePath))
            {
                await writer.WriteLineAsync("Rule ID,Severity,Project,File,Location,Message");
                
                foreach (var violation in violations.OrderBy(v => v.FilePath).ThenBy(v => v.Id))
                {
                    var csvLine = string.Join(",",
                        EscapeCsvField(violation.Id),
                        EscapeCsvField(violation.Severity),
                        EscapeCsvField(violation.ProjectName),
                        EscapeCsvField(Path.GetFileName(violation.FilePath)),
                        EscapeCsvField(violation.Location),
                        EscapeCsvField(violation.Message)
                    );
                    
                    await writer.WriteLineAsync(csvLine);
                }
            }
            
            Output.WriteLine($"Report generated at: {reportFilePath}");
            Output.WriteLine($"CSV report generated at: {csvFilePath}");
            
            return reportFilePath;
        }

        /// <summary>
        /// Loads and parses the code analysis ruleset file.
        /// </summary>
        /// <returns>Dictionary of rule IDs and their configured actions.</returns>
        private Dictionary<string, string> LoadRuleset()
        {
            var result = new Dictionary<string, string>();
            
            if (!File.Exists(RulesetPath))
            {
                Output.WriteLine($"Ruleset file not found at {RulesetPath}. Using default rules.");
                return result;
            }
            
            try
            {
                var content = File.ReadAllText(RulesetPath);
                var rulesetDoc = new System.Xml.XmlDocument();
                rulesetDoc.LoadXml(content);
                
                var ruleNodes = rulesetDoc.SelectNodes("//Rule");
                if (ruleNodes != null)
                {
                    foreach (System.Xml.XmlNode ruleNode in ruleNodes)
                    {
                        var id = ruleNode.Attributes?["Id"]?.Value;
                        var action = ruleNode.Attributes?["Action"]?.Value;
                        
                        if (!string.IsNullOrEmpty(id) && !string.IsNullOrEmpty(action))
                        {
                            result[id] = action;
                        }
                    }
                }
                
                Output.WriteLine($"Loaded {result.Count} rules from ruleset file");
            }
            catch (Exception ex)
            {
                Output.WriteLine($"Error loading ruleset: {ex.Message}");
            }
            
            return result;
        }

        /// <summary>
        /// Gets the list of critical security rules from the ruleset.
        /// </summary>
        /// <param name="ruleset">Dictionary of rule IDs and their configured actions.</param>
        /// <returns>List of critical security rule IDs.</returns>
        private List<string> GetCriticalSecurityRules(Dictionary<string, string> ruleset)
        {
            var criticalRules = new List<string>();
            
            // Rules set to "Error" severity are considered critical
            foreach (var rule in ruleset)
            {
                if (rule.Value.Equals("Error", StringComparison.OrdinalIgnoreCase) && IsSecurityRule(rule.Key))
                {
                    criticalRules.Add(rule.Key);
                }
            }
            
            // If no critical rules found in ruleset, use defaults from MaxAllowedViolationsByRule
            if (criticalRules.Count == 0)
            {
                criticalRules = MaxAllowedViolationsByRule
                    .Where(r => r.Value == 0 && IsSecurityRule(r.Key))
                    .Select(r => r.Key)
                    .ToList();
            }
            
            Output.WriteLine($"Identified {criticalRules.Count} critical security rules");
            return criticalRules;
        }

        /// <summary>
        /// Determines if a rule ID represents a security-related rule.
        /// </summary>
        /// <param name="ruleId">Rule identifier to check.</param>
        /// <returns>True if the rule is security-related, otherwise false.</returns>
        private bool IsSecurityRule(string ruleId)
        {
            // Microsoft security rules
            if (ruleId.StartsWith("CA2") || ruleId.StartsWith("CA3") || ruleId.StartsWith("CA5"))
            {
                return true;
            }
            
            // OWASP Security Code Scan rules
            if (ruleId.StartsWith("SCS"))
            {
                return true;
            }
            
            // Other security analyzers
            if (ruleId.StartsWith("S2") || ruleId.StartsWith("S3") || 
                ruleId.StartsWith("S4") || ruleId.StartsWith("S5") || 
                ruleId.StartsWith("S6"))
            {
                return true;
            }
            
            return false;
        }

        /// <summary>
        /// Determines if a file should be excluded from a specific rule check.
        /// </summary>
        /// <param name="filePath">Path of the file to check.</param>
        /// <param name="ruleId">Rule identifier to check against.</param>
        /// <returns>True if the file should be excluded, otherwise false.</returns>
        private bool ShouldExcludeFile(string filePath, string ruleId)
        {
            if (string.IsNullOrEmpty(filePath) || !ExcludedFiles.ContainsKey(ruleId))
            {
                return false;
            }
            
            var patterns = ExcludedFiles[ruleId];
            return patterns.Any(pattern => 
                {
                    if (pattern.Contains("*"))
                    {
                        var regex = new System.Text.RegularExpressions.Regex(
                            "^" + System.Text.RegularExpressions.Regex.Escape(pattern).Replace("\\*", ".*") + "$", 
                            System.Text.RegularExpressions.RegexOptions.IgnoreCase);
                            
                        return regex.IsMatch(Path.GetFileName(filePath));
                    }
                    else
                    {
                        return filePath.EndsWith(pattern, StringComparison.OrdinalIgnoreCase);
                    }
                });
        }

        private async Task<Project> CreateProjectFromPath(AdhocWorkspace workspace, string projectPath)
        {
            // This is a simplified version. In a real implementation, we would use MSBuild APIs
            // to load the project properly with all references and configurations
            try
            {
                var projectName = Path.GetFileNameWithoutExtension(projectPath);
                var projectDirectory = Path.GetDirectoryName(projectPath);
                
                var projectInfo = ProjectInfo.Create(
                    ProjectId.CreateNewId(),
                    VersionStamp.Create(),
                    projectName,
                    projectName,
                    LanguageNames.CSharp);
                    
                var project = workspace.AddProject(projectInfo);
                
                // Add source files
                var csharpFiles = Directory.GetFiles(projectDirectory, "*.cs", SearchOption.AllDirectories);
                foreach (var file in csharpFiles)
                {
                    try
                    {
                        var fileContent = await File.ReadAllTextAsync(file);
                        var documentInfo = DocumentInfo.Create(
                            DocumentId.CreateNewId(project.Id),
                            Path.GetFileName(file),
                            filePath: file,
                            loader: TextLoader.From(
                                TextAndVersion.Create(
                                    SourceText.From(fileContent), 
                                    VersionStamp.Create())));
                                    
                        workspace.AddDocument(documentInfo);
                    }
                    catch (Exception ex)
                    {
                        Output.WriteLine($"Error adding file {file}: {ex.Message}");
                    }
                }
                
                return project;
            }
            catch (Exception ex)
            {
                Output.WriteLine($"Error creating project from {projectPath}: {ex.Message}");
                return null;
            }
        }

        private IEnumerable<DiagnosticAnalyzer> ConfigureAnalyzers(List<string> enabledRuleIds)
        {
            // In a real implementation, we would load actual analyzer assemblies dynamically
            // and configure them based on the ruleset
            
            // Here we return an empty list as a placeholder - in a real implementation, 
            // this would return the properly configured analyzers
            var analyzers = new List<DiagnosticAnalyzer>();
            
            Output.WriteLine($"Configured {analyzers.Count} analyzers");
            return analyzers;
        }
        
        private string EscapeCsvField(string field)
        {
            if (string.IsNullOrEmpty(field))
            {
                return "";
            }
            
            // If the field contains a comma, a double quote, or a newline, enclose it in double quotes
            if (field.Contains(",") || field.Contains("\"") || field.Contains("\n") || field.Contains("\r"))
            {
                // Replace any double quotes with two double quotes
                field = field.Replace("\"", "\"\"");
                
                // Enclose the field in double quotes
                return $"\"{field}\"";
            }
            
            return field;
        }

        /// <summary>
        /// Cleans up resources after static code analysis.
        /// </summary>
        public void Cleanup()
        {
            // Delete temporary files if needed
            Output.WriteLine("Static code analysis cleanup completed");
        }
    }

    /// <summary>
    /// Represents a diagnostic result from code analysis.
    /// </summary>
    public class DiagnosticResult
    {
        /// <summary>
        /// Gets or sets the rule identifier.
        /// </summary>
        public string Id { get; set; }
        
        /// <summary>
        /// Gets or sets the severity level.
        /// </summary>
        public string Severity { get; set; }
        
        /// <summary>
        /// Gets or sets the location information.
        /// </summary>
        public string Location { get; set; }
        
        /// <summary>
        /// Gets or sets the diagnostic message.
        /// </summary>
        public string Message { get; set; }
        
        /// <summary>
        /// Gets or sets the project name.
        /// </summary>
        public string ProjectName { get; set; }
        
        /// <summary>
        /// Gets or sets the file path.
        /// </summary>
        public string FilePath { get; set; }
    }
}