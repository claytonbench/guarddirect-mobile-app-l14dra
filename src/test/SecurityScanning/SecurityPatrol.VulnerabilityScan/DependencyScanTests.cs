using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net;
using System.Threading;
using System.Threading.Tasks;
using System.Xml.Linq;
using Xunit;
using Xunit.Abstractions;
using OWASP.DependencyCheck.Core;
using OWASP.DependencyCheck.Reporting;
using NuGet.Protocol;
using NuGet.Protocol.Core.Types;
using NuGet.Versioning;

namespace SecurityPatrol.VulnerabilityScan
{
    /// <summary>
    /// Implements tests for scanning dependencies of the Security Patrol application
    /// to identify security vulnerabilities.
    /// </summary>
    public class DependencyScanTests
    {
        /// <summary>
        /// Gets the test output helper for logging.
        /// </summary>
        public ITestOutputHelper Output { get; }

        /// <summary>
        /// Gets the scan setup instance.
        /// </summary>
        public DependencyScanSetup ScanSetup { get; }

        /// <summary>
        /// Gets or sets the path where reports will be generated.
        /// </summary>
        public string ReportOutputPath { get; set; }

        /// <summary>
        /// Gets or sets the maximum allowed number of critical vulnerabilities.
        /// </summary>
        public int MaxAllowedCriticalVulnerabilities { get; set; }

        /// <summary>
        /// Gets or sets the maximum allowed number of high vulnerabilities.
        /// </summary>
        public int MaxAllowedHighVulnerabilities { get; set; }

        /// <summary>
        /// Gets the dictionary of vulnerability exclusions by package.
        /// </summary>
        public Dictionary<string, List<string>> VulnerabilityExclusions { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="DependencyScanTests"/> class.
        /// </summary>
        /// <param name="output">The test output helper for logging.</param>
        public DependencyScanTests(ITestOutputHelper output)
        {
            Output = output ?? throw new ArgumentNullException(nameof(output));
            ScanSetup = new DependencyScanSetup(output);
            
            // Set default thresholds for vulnerability severity
            MaxAllowedCriticalVulnerabilities = 0;  // No critical vulnerabilities allowed
            MaxAllowedHighVulnerabilities = 5;      // Allow up to 5 high vulnerabilities
            
            // Initialize report path (will be set during initialization)
            ReportOutputPath = null;
            
            // Initialize vulnerability exclusions dictionary
            VulnerabilityExclusions = new Dictionary<string, List<string>>
            {
                // Example: {"Newtonsoft.Json", new List<string> {"CVE-2023-XXXX"}}
                // Add known false positives or accepted risks here
            };
        }

        /// <summary>
        /// Initializes the dependency scanning environment asynchronously.
        /// </summary>
        /// <returns>A task representing the asynchronous initialization operation.</returns>
        [Fact(Skip = "Run manually due to long execution time")]
        public async Task InitializeAsync()
        {
            await ScanSetup.Initialize();
            ReportOutputPath = ScanSetup.ReportOutputDirectory;
            Output.WriteLine("Dependency scan initialization completed successfully.");
        }

        /// <summary>
        /// Scans all project dependencies for security vulnerabilities.
        /// </summary>
        /// <returns>A task representing the asynchronous scanning operation.</returns>
        [Fact(Skip = "Run manually due to long execution time")]
        public async Task ScanAllDependencies()
        {
            // Ensure initialization
            if (!ScanSetup.IsInitialized)
            {
                await ScanSetup.Initialize();
                ReportOutputPath = ScanSetup.ReportOutputDirectory;
            }

            // Get all project paths
            var projectPaths = ScanSetup.GetAllProjectPaths();
            
            Output.WriteLine($"Scanning {projectPaths.Count} projects for security vulnerabilities...");
            
            // Run dependency scan
            var vulnerabilityCounts = await RunDependencyScan(projectPaths, "AllDependencies");
            
            // Assertions to verify security requirements
            Assert.True(
                vulnerabilityCounts.TryGetValue("Critical", out int criticalCount) && 
                criticalCount <= MaxAllowedCriticalVulnerabilities,
                $"Found {criticalCount} critical vulnerabilities, which exceeds the maximum allowed ({MaxAllowedCriticalVulnerabilities})."
            );
            
            Assert.True(
                vulnerabilityCounts.TryGetValue("High", out int highCount) && 
                highCount <= MaxAllowedHighVulnerabilities,
                $"Found {highCount} high vulnerabilities, which exceeds the maximum allowed ({MaxAllowedHighVulnerabilities})."
            );
            
            Output.WriteLine("Dependency scan completed successfully.");
        }

        /// <summary>
        /// Scans mobile application dependencies for security vulnerabilities.
        /// </summary>
        /// <returns>A task representing the asynchronous scanning operation.</returns>
        [Fact(Skip = "Run manually due to long execution time")]
        public async Task ScanMobileAppDependencies()
        {
            // Ensure initialization
            if (!ScanSetup.IsInitialized)
            {
                await ScanSetup.Initialize();
                ReportOutputPath = ScanSetup.ReportOutputDirectory;
            }

            // Get mobile project paths
            var mobileProjectPaths = ScanSetup.GetProjectPaths("Mobile");
            
            Output.WriteLine($"Scanning {mobileProjectPaths.Count} mobile projects for security vulnerabilities...");
            
            // Run dependency scan for mobile projects
            var vulnerabilityCounts = await RunDependencyScan(mobileProjectPaths, "MobileAppDependencies");
            
            // Assertions to verify security requirements for mobile app
            Assert.True(
                vulnerabilityCounts.TryGetValue("Critical", out int criticalCount) && 
                criticalCount <= MaxAllowedCriticalVulnerabilities,
                $"Found {criticalCount} critical vulnerabilities in mobile app, which exceeds the maximum allowed ({MaxAllowedCriticalVulnerabilities})."
            );
            
            Assert.True(
                vulnerabilityCounts.TryGetValue("High", out int highCount) && 
                highCount <= MaxAllowedHighVulnerabilities,
                $"Found {highCount} high vulnerabilities in mobile app, which exceeds the maximum allowed ({MaxAllowedHighVulnerabilities})."
            );
            
            Output.WriteLine("Mobile app dependency scan completed successfully.");
        }

        /// <summary>
        /// Scans backend application dependencies for security vulnerabilities.
        /// </summary>
        /// <returns>A task representing the asynchronous scanning operation.</returns>
        [Fact(Skip = "Run manually due to long execution time")]
        public async Task ScanBackendDependencies()
        {
            // Ensure initialization
            if (!ScanSetup.IsInitialized)
            {
                await ScanSetup.Initialize();
                ReportOutputPath = ScanSetup.ReportOutputDirectory;
            }

            // Get backend project paths
            var backendProjectPaths = ScanSetup.GetProjectPaths("Backend");
            
            Output.WriteLine($"Scanning {backendProjectPaths.Count} backend projects for security vulnerabilities...");
            
            // Run dependency scan for backend projects
            var vulnerabilityCounts = await RunDependencyScan(backendProjectPaths, "BackendDependencies");
            
            // Assertions to verify security requirements for backend
            Assert.True(
                vulnerabilityCounts.TryGetValue("Critical", out int criticalCount) && 
                criticalCount <= MaxAllowedCriticalVulnerabilities,
                $"Found {criticalCount} critical vulnerabilities in backend, which exceeds the maximum allowed ({MaxAllowedCriticalVulnerabilities})."
            );
            
            Assert.True(
                vulnerabilityCounts.TryGetValue("High", out int highCount) && 
                highCount <= MaxAllowedHighVulnerabilities,
                $"Found {highCount} high vulnerabilities in backend, which exceeds the maximum allowed ({MaxAllowedHighVulnerabilities})."
            );
            
            Output.WriteLine("Backend dependency scan completed successfully.");
        }

        /// <summary>
        /// Verifies if NuGet packages have available updates with security fixes.
        /// </summary>
        /// <returns>A task representing the asynchronous verification operation.</returns>
        [Fact(Skip = "Run manually due to long execution time")]
        public async Task VerifyNuGetPackageUpdates()
        {
            // Ensure initialization
            if (!ScanSetup.IsInitialized)
            {
                await ScanSetup.Initialize();
                ReportOutputPath = ScanSetup.ReportOutputDirectory;
            }

            // Get all project paths
            var projectPaths = ScanSetup.GetAllProjectPaths();
            
            Output.WriteLine("Extracting NuGet package references from projects...");
            
            // Extract package references from projects
            var packageReferences = ExtractPackageReferences(projectPaths);
            
            Output.WriteLine($"Found {packageReferences.Count} unique NuGet package references.");
            
            // Check for updates
            Output.WriteLine("Checking for available package updates...");
            var packagesWithUpdates = await CheckNuGetPackageUpdates(packageReferences);
            
            // Generate report
            var reportPath = Path.Combine(ReportOutputPath, "NuGetPackageUpdateReport.html");
            using (var writer = new StreamWriter(reportPath))
            {
                writer.WriteLine("<html><head><title>NuGet Package Update Report</title>");
                writer.WriteLine("<style>body { font-family: Arial, sans-serif; margin: 20px; }");
                writer.WriteLine("table { border-collapse: collapse; width: 100%; }");
                writer.WriteLine("th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }");
                writer.WriteLine("th { background-color: #f2f2f2; }");
                writer.WriteLine(".security { background-color: #ffdddd; }");
                writer.WriteLine("</style></head><body>");
                writer.WriteLine("<h1>NuGet Package Update Report</h1>");
                writer.WriteLine($"<p>Generated on {DateTime.Now}</p>");
                writer.WriteLine("<table>");
                writer.WriteLine("<tr><th>Package</th><th>Current Version</th><th>Latest Version</th><th>Update Type</th></tr>");
                
                int securityUpdatesCount = 0;
                foreach (var package in packagesWithUpdates)
                {
                    var isSecurity = package.Value.Contains("Security");
                    if (isSecurity) securityUpdatesCount++;
                    
                    writer.WriteLine($"<tr{(isSecurity ? " class=\"security\"" : "")}>");
                    writer.WriteLine($"<td>{package.Key.Split('@')[0]}</td>");
                    writer.WriteLine($"<td>{package.Key.Split('@')[1]}</td>");
                    writer.WriteLine($"<td>{package.Value.Split(':')[0]}</td>");
                    writer.WriteLine($"<td>{package.Value.Split(':')[1]}</td>");
                    writer.WriteLine("</tr>");
                }
                
                writer.WriteLine("</table>");
                writer.WriteLine($"<p>Found {packagesWithUpdates.Count} packages with updates available, " +
                                $"including {securityUpdatesCount} with security fixes.</p>");
                writer.WriteLine("</body></html>");
            }
            
            Output.WriteLine($"Package update report generated at: {reportPath}");
            
            // Assert no critical security updates are pending
            var criticalSecurityUpdates = packagesWithUpdates
                .Where(p => p.Value.Contains("Security") && p.Value.Contains("Critical"))
                .ToList();
            
            Assert.Empty(criticalSecurityUpdates);
            
            Output.WriteLine("NuGet package verification completed successfully.");
        }

        /// <summary>
        /// Verifies that vulnerability suppressions are properly documented and justified.
        /// </summary>
        /// <returns>A task representing the asynchronous verification operation.</returns>
        [Fact(Skip = "Run manually due to long execution time")]
        public async Task VerifyVulnerabilitySuppressions()
        {
            // Ensure initialization
            if (!ScanSetup.IsInitialized)
            {
                await ScanSetup.Initialize();
                ReportOutputPath = ScanSetup.ReportOutputDirectory;
            }

            // Get suppression file path
            var suppressionFilePath = ScanSetup.GetSuppressionFile();
            
            if (!File.Exists(suppressionFilePath))
            {
                Output.WriteLine($"No suppression file found at: {suppressionFilePath}");
                return;
            }
            
            Output.WriteLine($"Verifying suppressions in: {suppressionFilePath}");
            
            // Parse suppression file
            var suppressions = ParseSuppressionFile(suppressionFilePath);
            
            Output.WriteLine($"Found {suppressions.Count} suppression entries.");
            
            // Validate suppressions
            var invalidSuppressions = new List<Dictionary<string, string>>();
            var expiredSuppressions = new List<Dictionary<string, string>>();
            
            foreach (var suppression in suppressions)
            {
                // Check for required documentation
                if (!suppression.ContainsKey("notes") || string.IsNullOrWhiteSpace(suppression["notes"]))
                {
                    invalidSuppressions.Add(suppression);
                }
                
                // Check for expiration date
                if (suppression.TryGetValue("until", out string untilDate) && 
                    DateTime.TryParse(untilDate, out DateTime expirationDate) &&
                    expirationDate < DateTime.Now)
                {
                    expiredSuppressions.Add(suppression);
                }
            }
            
            // Generate report
            var reportPath = Path.Combine(ReportOutputPath, "SuppressionVerificationReport.html");
            using (var writer = new StreamWriter(reportPath))
            {
                writer.WriteLine("<html><head><title>Vulnerability Suppression Verification Report</title>");
                writer.WriteLine("<style>body { font-family: Arial, sans-serif; margin: 20px; }");
                writer.WriteLine("table { border-collapse: collapse; width: 100%; }");
                writer.WriteLine("th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }");
                writer.WriteLine("th { background-color: #f2f2f2; }");
                writer.WriteLine(".invalid { background-color: #ffdddd; }");
                writer.WriteLine(".expired { background-color: #ffffcc; }");
                writer.WriteLine("</style></head><body>");
                writer.WriteLine("<h1>Vulnerability Suppression Verification Report</h1>");
                writer.WriteLine($"<p>Generated on {DateTime.Now}</p>");
                
                if (invalidSuppressions.Any())
                {
                    writer.WriteLine("<h2>Invalid Suppressions (Missing Documentation)</h2>");
                    writer.WriteLine("<table>");
                    writer.WriteLine("<tr><th>CVE</th><th>Package</th><th>Issue</th></tr>");
                    
                    foreach (var suppression in invalidSuppressions)
                    {
                        writer.WriteLine("<tr class=\"invalid\">");
                        writer.WriteLine($"<td>{suppression.GetValueOrDefault("cve", "N/A")}</td>");
                        writer.WriteLine($"<td>{suppression.GetValueOrDefault("packageUrl", "N/A")}</td>");
                        writer.WriteLine("<td>Missing or empty notes field</td>");
                        writer.WriteLine("</tr>");
                    }
                    
                    writer.WriteLine("</table>");
                }
                
                if (expiredSuppressions.Any())
                {
                    writer.WriteLine("<h2>Expired Suppressions</h2>");
                    writer.WriteLine("<table>");
                    writer.WriteLine("<tr><th>CVE</th><th>Package</th><th>Expiration Date</th></tr>");
                    
                    foreach (var suppression in expiredSuppressions)
                    {
                        writer.WriteLine("<tr class=\"expired\">");
                        writer.WriteLine($"<td>{suppression.GetValueOrDefault("cve", "N/A")}</td>");
                        writer.WriteLine($"<td>{suppression.GetValueOrDefault("packageUrl", "N/A")}</td>");
                        writer.WriteLine($"<td>{suppression.GetValueOrDefault("until", "N/A")}</td>");
                        writer.WriteLine("</tr>");
                    }
                    
                    writer.WriteLine("</table>");
                }
                
                if (!invalidSuppressions.Any() && !expiredSuppressions.Any())
                {
                    writer.WriteLine("<p>All suppressions are properly documented and have not expired.</p>");
                }
                
                writer.WriteLine("</body></html>");
            }
            
            Output.WriteLine($"Suppression verification report generated at: {reportPath}");
            
            // Assert all suppressions are properly documented
            Assert.Empty(invalidSuppressions);
            
            // Log expired suppressions but don't fail the test
            if (expiredSuppressions.Any())
            {
                Output.WriteLine($"Warning: Found {expiredSuppressions.Count} expired suppressions that should be reviewed.");
            }
            
            Output.WriteLine("Vulnerability suppression verification completed successfully.");
        }

        /// <summary>
        /// Runs dependency scan with specified configuration.
        /// </summary>
        /// <param name="projectPaths">The list of project paths to scan.</param>
        /// <param name="outputName">The name for output reports.</param>
        /// <returns>Dictionary of vulnerability counts by severity.</returns>
        private async Task<Dictionary<string, int>> RunDependencyScan(List<string> projectPaths, string outputName)
        {
            var vulnerabilityCounts = new Dictionary<string, int>
            {
                { "Critical", 0 },
                { "High", 0 },
                { "Medium", 0 },
                { "Low", 0 }
            };
            
            try
            {
                // Get scan engine
                var engine = ScanSetup.GetScanEngine() as Engine;
                if (engine == null)
                {
                    throw new InvalidOperationException("Scan engine is not properly initialized.");
                }
                
                // Set up scan for specific projects
                foreach (var projectPath in projectPaths)
                {
                    engine.Config.ScanPath.Add(projectPath);
                }
                
                // Set output file name
                engine.Config.OutputFileName = outputName;
                
                Output.WriteLine("Starting dependency scan...");
                
                // Run scan
                await Task.Run(() => 
                {
                    try
                    {
                        engine.Analyze();
                    }
                    catch (Exception ex)
                    {
                        Output.WriteLine($"Warning: Exception during scan analysis: {ex.Message}");
                        // Continue despite the error to process any results that were generated
                    }
                });
                
                Output.WriteLine("Dependency scan analysis completed.");
                
                // Generate report
                await Task.Run(() => 
                {
                    try
                    {
                        engine.WriteReports();
                    }
                    catch (Exception ex)
                    {
                        Output.WriteLine($"Warning: Exception writing reports: {ex.Message}");
                    }
                });
                
                Output.WriteLine($"Scan reports generated in {ReportOutputPath}");
                
                // Process scan results
                vulnerabilityCounts = ProcessScanResults(engine.ScanResultCallbackObject);
                
                // Generate detailed vulnerability report
                await GenerateVulnerabilityReport(engine.ScanResultCallbackObject, outputName);
                
                return vulnerabilityCounts;
            }
            catch (Exception ex)
            {
                Output.WriteLine($"Error running dependency scan: {ex.Message}");
                return vulnerabilityCounts;
            }
        }

        /// <summary>
        /// Processes the results of dependency scanning.
        /// </summary>
        /// <param name="scanResults">The scan results object.</param>
        /// <returns>Dictionary of vulnerability counts by severity.</returns>
        private Dictionary<string, int> ProcessScanResults(object scanResults)
        {
            var vulnerabilityCounts = new Dictionary<string, int>
            {
                { "Critical", 0 },
                { "High", 0 },
                { "Medium", 0 },
                { "Low", 0 }
            };
            
            try
            {
                // Handle if scan results is null
                if (scanResults == null)
                {
                    Output.WriteLine("Warning: Scan results are null - no vulnerability data available.");
                    return vulnerabilityCounts;
                }
                
                // Use reflection to safely access the scan results
                // This makes our code more resilient to API changes
                var resultsType = scanResults.GetType();
                
                // Try to get Dependencies property
                var dependenciesProp = resultsType.GetProperty("Dependencies");
                if (dependenciesProp == null)
                {
                    Output.WriteLine("Warning: Could not access Dependencies property in scan results.");
                    return vulnerabilityCounts;
                }
                
                var dependencies = dependenciesProp.GetValue(scanResults) as IEnumerable<object>;
                if (dependencies == null)
                {
                    Output.WriteLine("Warning: Dependencies collection is null or not enumerable.");
                    return vulnerabilityCounts;
                }
                
                foreach (var dependency in dependencies)
                {
                    var depType = dependency.GetType();
                    
                    // Get package name
                    var packageNameProp = depType.GetProperty("PackageName") ?? 
                                         depType.GetProperty("Name") ?? 
                                         depType.GetProperty("DisplayName");
                    string packageName = "Unknown";
                    if (packageNameProp != null)
                    {
                        packageName = packageNameProp.GetValue(dependency)?.ToString() ?? "Unknown";
                    }
                    
                    // Get vulnerabilities
                    var vulnProp = depType.GetProperty("Vulnerabilities");
                    if (vulnProp == null) continue;
                    
                    var vulnerabilities = vulnProp.GetValue(dependency) as IEnumerable<object>;
                    if (vulnerabilities == null) continue;
                    
                    foreach (var vulnerability in vulnerabilities)
                    {
                        // Skip null vulnerabilities
                        if (vulnerability == null) continue;
                        
                        var vulnType = vulnerability.GetType();
                        
                        // Get vulnerability name/ID
                        var vulnNameProp = vulnType.GetProperty("Name") ?? 
                                          vulnType.GetProperty("Id") ?? 
                                          vulnType.GetProperty("CveId");
                        string vulnName = "Unknown";
                        if (vulnNameProp != null)
                        {
                            vulnName = vulnNameProp.GetValue(vulnerability)?.ToString() ?? "Unknown";
                        }
                        
                        // Skip excluded vulnerabilities
                        if (IsVulnerabilityExcluded(packageName, vulnName))
                        {
                            Output.WriteLine($"Skipping excluded vulnerability: {vulnName} in {packageName}");
                            continue;
                        }
                        
                        // Get CVSS score - try different property names
                        float cvssScore = 0;
                        var cvssProp = vulnType.GetProperty("CVSS3") ?? 
                                      vulnType.GetProperty("CVSS") ?? 
                                      vulnType.GetProperty("CvssScore");
                        
                        if (cvssProp != null)
                        {
                            var cvssValue = cvssProp.GetValue(vulnerability);
                            if (cvssValue != null)
                            {
                                float.TryParse(cvssValue.ToString(), out cvssScore);
                            }
                        }
                        
                        // Categorize by severity
                        if (cvssScore >= 9.0)
                        {
                            vulnerabilityCounts["Critical"]++;
                        }
                        else if (cvssScore >= 7.0)
                        {
                            vulnerabilityCounts["High"]++;
                        }
                        else if (cvssScore >= 4.0)
                        {
                            vulnerabilityCounts["Medium"]++;
                        }
                        else
                        {
                            vulnerabilityCounts["Low"]++;
                        }
                    }
                }
                
                // Log summary
                Output.WriteLine("Vulnerability Summary:");
                foreach (var severity in vulnerabilityCounts)
                {
                    Output.WriteLine($"- {severity.Key}: {severity.Value}");
                }
                
                return vulnerabilityCounts;
            }
            catch (Exception ex)
            {
                Output.WriteLine($"Error processing scan results: {ex.Message}");
                return vulnerabilityCounts;
            }
        }

        /// <summary>
        /// Checks if a vulnerability is in the exclusions list.
        /// </summary>
        /// <param name="packageName">The package name.</param>
        /// <param name="vulnerabilityId">The vulnerability ID (CVE).</param>
        /// <returns>True if the vulnerability is excluded, false otherwise.</returns>
        private bool IsVulnerabilityExcluded(string packageName, string vulnerabilityId)
        {
            if (VulnerabilityExclusions.TryGetValue(packageName, out var excludedVulnerabilities))
            {
                return excludedVulnerabilities.Contains(vulnerabilityId);
            }
            
            return false;
        }

        /// <summary>
        /// Generates a detailed report of identified vulnerabilities.
        /// </summary>
        /// <param name="scanResults">The scan results object.</param>
        /// <param name="reportName">The name for the report file.</param>
        /// <returns>Path to the generated report file.</returns>
        private async Task<string> GenerateVulnerabilityReport(object scanResults, string reportName)
        {
            var reportPath = Path.Combine(ReportOutputPath, $"{reportName}_VulnerabilityDetails.html");
            
            try
            {
                using (var writer = new StreamWriter(reportPath))
                {
                    await writer.WriteLineAsync("<html><head><title>Detailed Vulnerability Report</title>");
                    await writer.WriteLineAsync("<style>body { font-family: Arial, sans-serif; margin: 20px; }");
                    await writer.WriteLineAsync("table { border-collapse: collapse; width: 100%; }");
                    await writer.WriteLineAsync("th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }");
                    await writer.WriteLineAsync("th { background-color: #f2f2f2; }");
                    await writer.WriteLineAsync(".critical { background-color: #ffdddd; }");
                    await writer.WriteLineAsync(".high { background-color: #ffffcc; }");
                    await writer.WriteLineAsync(".medium { background-color: #e6ffe6; }");
                    await writer.WriteLineAsync(".low { background-color: #e6f3ff; }");
                    await writer.WriteLineAsync("</style></head><body>");
                    await writer.WriteLineAsync("<h1>Detailed Vulnerability Report</h1>");
                    await writer.WriteLineAsync($"<p>Generated on {DateTime.Now}</p>");
                    
                    if (scanResults == null)
                    {
                        await writer.WriteLineAsync("<p>No vulnerability data available.</p>");
                        await writer.WriteLineAsync("</body></html>");
                        return reportPath;
                    }
                    
                    // Use reflection to safely access scan results
                    var resultsType = scanResults.GetType();
                    var dependenciesProp = resultsType.GetProperty("Dependencies");
                    
                    if (dependenciesProp == null)
                    {
                        await writer.WriteLineAsync("<p>Could not access dependency data.</p>");
                        await writer.WriteLineAsync("</body></html>");
                        return reportPath;
                    }
                    
                    var dependencies = dependenciesProp.GetValue(scanResults) as IEnumerable<object>;
                    if (dependencies == null)
                    {
                        await writer.WriteLineAsync("<p>Dependency data is not available.</p>");
                        await writer.WriteLineAsync("</body></html>");
                        return reportPath;
                    }
                    
                    // Collect vulnerable dependencies
                    var vulnerableDependencies = new List<(object Dependency, string PackageName, string Version)>();
                    
                    foreach (var dependency in dependencies)
                    {
                        var depType = dependency.GetType();
                        
                        // Get vulnerabilities property
                        var vulnProp = depType.GetProperty("Vulnerabilities");
                        if (vulnProp == null) continue;
                        
                        var vulnerabilities = vulnProp.GetValue(dependency) as IEnumerable<object>;
                        if (vulnerabilities == null || !vulnerabilities.Any()) continue;
                        
                        // Get package name
                        var packageNameProp = depType.GetProperty("PackageName") ?? 
                                             depType.GetProperty("Name") ?? 
                                             depType.GetProperty("DisplayName");
                        string packageName = "Unknown";
                        if (packageNameProp != null)
                        {
                            packageName = packageNameProp.GetValue(dependency)?.ToString() ?? "Unknown";
                        }
                        
                        // Get version
                        var versionProp = depType.GetProperty("Version") ?? 
                                        depType.GetProperty("VersionInfo");
                        string version = "Unknown";
                        if (versionProp != null)
                        {
                            version = versionProp.GetValue(dependency)?.ToString() ?? "Unknown";
                        }
                        
                        vulnerableDependencies.Add((dependency, packageName, version));
                    }
                    
                    if (!vulnerableDependencies.Any())
                    {
                        await writer.WriteLineAsync("<p>No vulnerabilities found.</p>");
                        await writer.WriteLineAsync("</body></html>");
                        return reportPath;
                    }
                    
                    await writer.WriteLineAsync("<h2>Vulnerable Dependencies</h2>");
                    await writer.WriteLineAsync("<table>");
                    await writer.WriteLineAsync("<tr><th>Package</th><th>Version</th><th>CVE</th><th>Severity</th><th>CVSS Score</th><th>Description</th></tr>");
                    
                    int criticalCount = 0;
                    int highCount = 0;
                    int mediumCount = 0;
                    int lowCount = 0;
                    
                    foreach (var (dependency, packageName, version) in vulnerableDependencies)
                    {
                        var depType = dependency.GetType();
                        var vulnProp = depType.GetProperty("Vulnerabilities");
                        var vulnerabilities = vulnProp.GetValue(dependency) as IEnumerable<object>;
                        
                        foreach (var vulnerability in vulnerabilities)
                        {
                            if (vulnerability == null) continue;
                            
                            var vulnType = vulnerability.GetType();
                            
                            // Get vulnerability name/ID
                            var vulnNameProp = vulnType.GetProperty("Name") ?? 
                                              vulnType.GetProperty("Id") ?? 
                                              vulnType.GetProperty("CveId");
                            string vulnName = "Unknown";
                            if (vulnNameProp != null)
                            {
                                vulnName = vulnNameProp.GetValue(vulnerability)?.ToString() ?? "Unknown";
                            }
                            
                            // Get CVSS score
                            float cvssScore = 0;
                            var cvssProp = vulnType.GetProperty("CVSS3") ?? 
                                          vulnType.GetProperty("CVSS") ?? 
                                          vulnType.GetProperty("CvssScore");
                            
                            if (cvssProp != null)
                            {
                                var cvssValue = cvssProp.GetValue(vulnerability);
                                if (cvssValue != null)
                                {
                                    float.TryParse(cvssValue.ToString(), out cvssScore);
                                }
                            }
                            
                            // Get description
                            string description = "No description available";
                            var descProp = vulnType.GetProperty("Description");
                            if (descProp != null)
                            {
                                description = descProp.GetValue(vulnerability)?.ToString() ?? description;
                            }
                            
                            string severityClass;
                            string severity;
                            
                            if (cvssScore >= 9.0)
                            {
                                severityClass = "critical";
                                severity = "Critical";
                                criticalCount++;
                            }
                            else if (cvssScore >= 7.0)
                            {
                                severityClass = "high";
                                severity = "High";
                                highCount++;
                            }
                            else if (cvssScore >= 4.0)
                            {
                                severityClass = "medium";
                                severity = "Medium";
                                mediumCount++;
                            }
                            else
                            {
                                severityClass = "low";
                                severity = "Low";
                                lowCount++;
                            }
                            
                            await writer.WriteLineAsync($"<tr class=\"{severityClass}\">");
                            await writer.WriteLineAsync($"<td>{WebUtility.HtmlEncode(packageName)}</td>");
                            await writer.WriteLineAsync($"<td>{WebUtility.HtmlEncode(version)}</td>");
                            await writer.WriteLineAsync($"<td>{WebUtility.HtmlEncode(vulnName)}</td>");
                            await writer.WriteLineAsync($"<td>{severity}</td>");
                            await writer.WriteLineAsync($"<td>{cvssScore:F1}</td>");
                            await writer.WriteLineAsync($"<td>{WebUtility.HtmlEncode(description)}</td>");
                            await writer.WriteLineAsync("</tr>");
                        }
                    }
                    
                    await writer.WriteLineAsync("</table>");
                    
                    // Add summary
                    await writer.WriteLineAsync("<h2>Summary</h2>");
                    await writer.WriteLineAsync("<ul>");
                    await writer.WriteLineAsync($"<li>Critical: {criticalCount}</li>");
                    await writer.WriteLineAsync($"<li>High: {highCount}</li>");
                    await writer.WriteLineAsync($"<li>Medium: {mediumCount}</li>");
                    await writer.WriteLineAsync($"<li>Low: {lowCount}</li>");
                    await writer.WriteLineAsync($"<li>Total: {criticalCount + highCount + mediumCount + lowCount}</li>");
                    await writer.WriteLineAsync("</ul>");
                    
                    await writer.WriteLineAsync("</body></html>");
                }
                
                Output.WriteLine($"Detailed vulnerability report generated at: {reportPath}");
                return reportPath;
            }
            catch (Exception ex)
            {
                Output.WriteLine($"Error generating vulnerability report: {ex.Message}");
                return null;
            }
        }

        /// <summary>
        /// Checks for available updates for NuGet packages.
        /// </summary>
        /// <param name="packages">Dictionary of package names and versions.</param>
        /// <returns>Dictionary of packages with available updates.</returns>
        private async Task<Dictionary<string, string>> CheckNuGetPackageUpdates(Dictionary<string, string> packages)
        {
            var result = new Dictionary<string, string>();
            
            try
            {
                // Set up NuGet repository
                var providers = new List<Lazy<INuGetResourceProvider>>();
                providers.AddRange(Repository.Provider.GetCoreV3());
                
                var packageSource = new PackageSource("https://api.nuget.org/v3/index.json");
                var repository = new SourceRepository(packageSource, providers);
                
                var packageMetadataResource = await repository.GetResourceAsync<PackageMetadataResource>();
                
                // Check each package for updates
                foreach (var package in packages)
                {
                    try
                    {
                        var packageName = package.Key;
                        var currentVersion = NuGetVersion.Parse(package.Value);
                        
                        // Get package metadata
                        var packageMetadata = await packageMetadataResource.GetMetadataAsync(
                            packageName, 
                            includePrerelease: false, 
                            includeUnlisted: false, 
                            CancellationToken.None);
                        
                        var latestPackage = packageMetadata.OrderByDescending(p => p.Identity.Version).FirstOrDefault();
                        
                        if (latestPackage != null && latestPackage.Identity.Version > currentVersion)
                        {
                            var updateType = "Regular";
                            
                            // Check if this might be a security update by examining release notes
                            var releaseNotes = latestPackage.ReleaseNotes ?? string.Empty;
                            if (releaseNotes.Contains("security", StringComparison.OrdinalIgnoreCase) || 
                                releaseNotes.Contains("CVE", StringComparison.OrdinalIgnoreCase) ||
                                releaseNotes.Contains("vulnerability", StringComparison.OrdinalIgnoreCase) ||
                                releaseNotes.Contains("exploit", StringComparison.OrdinalIgnoreCase))
                            {
                                updateType = "Security";
                                
                                // Check if it might be a critical update
                                if (releaseNotes.Contains("critical", StringComparison.OrdinalIgnoreCase))
                                {
                                    updateType = "Security:Critical";
                                }
                                else
                                {
                                    updateType = "Security:Important";
                                }
                            }
                            
                            result.Add($"{packageName}@{currentVersion}", $"{latestPackage.Identity.Version}:{updateType}");
                        }
                    }
                    catch (Exception ex)
                    {
                        Output.WriteLine($"Error checking updates for package {package.Key}: {ex.Message}");
                    }
                }
                
                return result;
            }
            catch (Exception ex)
            {
                Output.WriteLine($"Error checking NuGet package updates: {ex.Message}");
                return result;
            }
        }

        /// <summary>
        /// Extracts NuGet package references from project files.
        /// </summary>
        /// <param name="projectPaths">The list of project file paths.</param>
        /// <returns>Dictionary of package names and versions.</returns>
        private Dictionary<string, string> ExtractPackageReferences(List<string> projectPaths)
        {
            var result = new Dictionary<string, string>();
            
            try
            {
                foreach (var projectPath in projectPaths)
                {
                    try
                    {
                        var projectContent = File.ReadAllText(projectPath);
                        var projectXml = XDocument.Parse(projectContent);
                        
                        var packageReferences = projectXml.Descendants()
                            .Where(e => e.Name.LocalName == "PackageReference")
                            .ToList();
                        
                        foreach (var packageRef in packageReferences)
                        {
                            var packageName = packageRef.Attribute("Include")?.Value;
                            var packageVersion = packageRef.Attribute("Version")?.Value;
                            
                            if (!string.IsNullOrEmpty(packageName) && !string.IsNullOrEmpty(packageVersion))
                            {
                                // Use the latest version if the package appears in multiple projects
                                if (result.TryGetValue(packageName, out string existingVersion))
                                {
                                    var existing = NuGetVersion.Parse(existingVersion);
                                    var current = NuGetVersion.Parse(packageVersion);
                                    
                                    if (current > existing)
                                    {
                                        result[packageName] = packageVersion;
                                    }
                                }
                                else
                                {
                                    result.Add(packageName, packageVersion);
                                }
                            }
                        }
                    }
                    catch (Exception ex)
                    {
                        Output.WriteLine($"Error extracting package references from {projectPath}: {ex.Message}");
                    }
                }
                
                return result;
            }
            catch (Exception ex)
            {
                Output.WriteLine($"Error extracting package references: {ex.Message}");
                return result;
            }
        }

        /// <summary>
        /// Parses the vulnerability suppression file.
        /// </summary>
        /// <param name="suppressionFilePath">The path to the suppression file.</param>
        /// <returns>List of suppression entries with metadata.</returns>
        private List<Dictionary<string, string>> ParseSuppressionFile(string suppressionFilePath)
        {
            var result = new List<Dictionary<string, string>>();
            
            try
            {
                var suppressionXml = XDocument.Load(suppressionFilePath);
                var suppressions = suppressionXml.Descendants()
                    .Where(e => e.Name.LocalName == "suppress")
                    .ToList();
                
                foreach (var suppression in suppressions)
                {
                    var entry = new Dictionary<string, string>();
                    
                    // Extract notes
                    var notes = suppression.Elements()
                        .FirstOrDefault(e => e.Name.LocalName == "notes");
                    if (notes != null)
                    {
                        entry["notes"] = notes.Value;
                    }
                    
                    // Extract package URL
                    var packageUrl = suppression.Elements()
                        .FirstOrDefault(e => e.Name.LocalName == "packageUrl");
                    if (packageUrl != null)
                    {
                        entry["packageUrl"] = packageUrl.Value;
                    }
                    
                    // Extract CVE
                    var cve = suppression.Elements()
                        .FirstOrDefault(e => e.Name.LocalName == "cve");
                    if (cve != null)
                    {
                        entry["cve"] = cve.Value;
                    }
                    
                    // Extract until date (expiration)
                    var until = suppression.Elements()
                        .FirstOrDefault(e => e.Name.LocalName == "until");
                    if (until != null)
                    {
                        entry["until"] = until.Value;
                    }
                    
                    result.Add(entry);
                }
                
                return result;
            }
            catch (Exception ex)
            {
                Output.WriteLine($"Error parsing suppression file: {ex.Message}");
                return result;
            }
        }

        /// <summary>
        /// Cleans up resources after dependency scanning.
        /// </summary>
        public void Cleanup()
        {
            ScanSetup.Cleanup();
            Output.WriteLine("Dependency scan tests cleanup completed.");
        }
    }
}